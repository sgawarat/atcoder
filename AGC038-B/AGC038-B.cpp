// 取り得る数列の個数は[1,
// N-K+1]の範囲にある。その数列が重複するかどうかを判定すればO(N)でできそう。
//
// ソートして順番が変化しなければ、それは元の順列と同じである。
// ソートして順番が変化すれば、それは重複しない可能性があるので、その場合を考える。
//
// [i, i+K)と[j, j+K)をソート範囲とする列を考える。
// ソート範囲が重ならない場合、その範囲内が元の列から変化するので、iの列はどのjの列とも重複しない。
// ソート範囲が重なる場合、P_i <= ... <= (P_j, ..., P_K) <= ... <=
// P_{j+K}を満たすと、iの列とjの列は重複する。 このとき、x∈(i, j)の列は、P_i <=
// ... <= P_x <= ... <= (P_j, ..., P_K) <= ... <= P_{x+K} <= ... <=
// P_{j+K}となるため、iの列ともjの列とも重複する。
// 逆に考えると、iの列はi+1の列と重複しなければ、i+2以降の列とも重複しないので、全体からユニークである。
#include <iostream>
#include <set>
#include <vector>

int P[200000];  // オリジナルの順列


int main() {
  // 情報を読み取る
  size_t N = 0;  // 要素の個数
  size_t K = 0;  // 並び替える要素の個数
  std::cin >> N >> K;

  // 列の値を読み取る
  for (size_t i = 0; i < N; ++i) {
    std::cin >> P[i];
  }

  // ソート範囲内が既にソート済みかどうかを調べる
  std::vector<bool> sorted(N - K + 1);
  for (size_t i = 0, j = 0, count = 0; i < sorted.size(); ++i) {
    // 降順になっている要素を累積的に数える
    while (j < i + K - 1) {
      if (P[j] > P[j + 1]) count++;
      j++;
    }

    sorted[i] = (count == 0);

    // 先頭の要素を取り除く
    if (P[i] > P[i + 1]) count--;
  }

  // ソート範囲が重なる場合を調べる
  std::set<int> sub;  // ソートされた値を取り出すためのコンテナ
  bool orig = sorted.front();  // オリジナルの順列パターンを含むか
  size_t result = orig ? 0 : 1;  // パターンの個数。0
  for (size_t i = 0, j = 0; i < N - K; ++i) {
    // ソート範囲を累積的にソートする
    while (j < i + K + 1) {
      sub.insert(P[j]);
      j++;
    }

    // 重複しないパターンかどうかを調べる
    if (*sub.cbegin() != P[i] || *--sub.cend() != P[i + K]) {
      // 既にソート済みであれば、オリジナルの順列パターンとして数える
      if (sorted[i + 1]) {
        orig = true;
      } else {
        result++;
      }
    }

    // 先頭の要素を取り除く
    sub.erase(P[i]);
  }

  // オリジナルの順列パターンを加える
  result += orig ? 1 : 0;

  // 結果発表
  std::cout << result;
  return 0;
}
